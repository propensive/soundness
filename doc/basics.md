All terms and types are defined in the `capricious` package:
```scala
import capricious.*
```

### Generating random values

A random instance of some type, `Type` can be constructed by calling,
```scala
val randomInt = random[Int]()
val randomBoolean = random[Boolean]()
```
or, if the type can be inferred from the context, just,
```scala
val randomChar: Char = random()
```

Random values can only be generated for certain types, but this includes most
primitive types, and any type for which an `Arbitrary` typeclass instance
exists.

A value generated with `random` should be unpredictable, since it will be
determined from a random 64-bit value provided by the JVM's default random
number generator. This is, however, only a pseudorandom number generator, and
the sequence it produces will be deterministic, albeit difficult to predict.

### Repeatability

Randomness is useful, but it can undermine repeatability. So a more
fine-grained mechanism is available for generating random values with the same
probability distribution, but using different random number generators (RNGs),
including seeded RNGs which will produce a repeatable sequence of values each
time.

The code which will generate random values of this form must be delimited in a
`stochastic` block. Within this block, new random values can be generated by
calling `arbitrary` in much the same way as we called `random` before.

But in order to construct a new `stochastic` block, a random number generator
should be specified, with a seed value if necessary. For now, we will used the
default random number generator, with a specified seed value.

For example,
```scala
given Seed = Seed(12L)
import randomNumberGenerators.seeded

def main(): Unit = stochastic:
  println(arbitrary[Int]())
  println(arbitrary[Char]())
```


Note that the sequence of random values generated within a stochastic block
will be deterministic, so long as the code is deterministic. This is generally
true for single-threaded code, but concurrency can introduce nondeterminism,
since multiple threads could cause random values to be generated in a different
order across threads each time the code is run. Therefore, it is important to
initiate a new `stochastic` block for each thread, using a seed generated from
the parent thread, like so:
```scala
import parasite.*

given Seed = Seed(42L)
import randomNumberGenerators.seeded

def main(): Unit =
  stochastic:
    val seed1 = arbitrary[Seed]()
    val seed2 = arbitrary[Seed]()
  
    val async1 = Async:
      stochastic(using seed1):
        println(arbitrary[Int])

    val async2 = Async:
      stochastic(using seed2):
        println(arbitrary[Int])

    async1.await()
    async2.await()
```

### Generating random `Double`s

Random `Double`s can be generated only if a probability distribution is
specified. Since `Double`s are a 64-bit approximation of the set of real
numbers, which is an infinite set, there is no clear answer for what
probability each possible `Double` value should have of being chosen randomly.
Hence, several options are provided, which can be selected by importing them as
contextual values:

- `import randomDistributions.gaussian` - the Gaussian distribution with mean,
  `0`, and variance, `1`
- `import randomDistributions.uniformUnitInterval` - uniform across the
  interval `[0, 1]`
- `import randomDistributions.uniformSymmetricUnitInterval` - uniform across
  the interval `[-1, 1]`
- `import randomDistributions.binary` - uniform across the 64-bit binary
  representations of IEEE 754
  double-precision values
- `given Distribution = Gamma(shape, scale)` - a Gamma distribution with a
  specified shape (k) and
  scale (θ)
- `given Distribution = Gaussian(mean, standardDeviation)` - a Gaussian
  (normal) distribution with specified mean (x̄) and standard deviation (σ)
- `given Distribution = UniformDistribution(start, end)` - a uniform
  distribution in the range `[start, end]`

### Random sources

Several (pseudo-)random number generators are available, sometimes in seeded and unseeded variants:

- `import randomNumberGenerators.unseeded` - a "standard" generator, with no seed
- `import randomNumberGenerators.seeded` - a "standard" generator, requiring a contextual `Seed` instance
- `import randomNumberGenerators.secureUnseeded` - a "secure" generator, with no seed
- `import randomNumberGenerators.secureSeeded` - a "secure" generator, requiring a contextual `Seed` instance
- `import randomNumberGenerators.stronglySecure` - a "strongly secure" generator, which cannot be seeded

Those generators which require a seed value can define it, as a `Long` value, with:
```scala
given Seed = Seed(23956242374982L)
```
or as a byte array of arbitrary length, for example,
```scala
given Seed = Seed(Bytes(78, 124, 19, 3, 52, 99, 112, 89, 8, 7, 12))
```
though different random number generators may only use as much of the seed value as they need.

### The `Arbitrary` Typeclass

The typeclass, `Arbitrary`, will produce random instances of its type parameter. Given instances are
predefined for a few basic types, but custom instances can be constructed by implementing the trait:
```scala
trait Arbitrary[ValueType]:
  def from(random: Random): ValueType
```

An implementation of `from` should call `random`'s methods as many times as
necessary to construct a new, random instance of `ValueType`. Although random,
the instance of `ValueType` should depend deterministically on the values
produced by `random`.

### Product and Sum types

Capricious can construct random instances of product types such as case classes and enumeration cases, and
sum types like `enum`s and sealed traits, as long as each field of the product and variant of the sum has
a valid `Arbitrary` instance.
